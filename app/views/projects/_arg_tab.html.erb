<% if @data.present? %>
<div class="m-l white-bg header-box">
    <div id="force-graph"></div>
    <div style="height: 3em; position: relative">
        <div style="margin: 0; position: absolute; top: 30%; left: 50%; margin-right: -50%; transform: translate(-50%, -50%)">
            <input id="LAST_14d" type="button" value="Last 14 days">
            <input id="LAST_30d" type="button" value="Last 30 days">
            <input id="LAST_60d" type="button" value="Last 60 days">
            <input id="LAST_90d" type="button" value="Last 90 days">
            <input id="LAST_180d" type="button" value="Last 180 days">
            <input id="ALL_DATES" type="button" value="All" class="selected">
        </div>
    </div>
</div>

<div class="panel blank-panel">
    <div class="panel-body">
      <div class="ibox-content">
        <table id="contacts-table" class="table table-striped table-hover table-responsive">
          <thead>
          <tr>
            <th>Name</th>
            <th>Buyer Role</th>
            <th>Last Touch</th>
            <th>Last Meeting</th>
            <th>Next Meeting</th>
            <th>Notes</th>
          </tr>
          </thead>
          <tbody>
          <% @contacts.each do |contact| %>
            <tr>
              <td>
                <div>
                  <%= link_to get_full_name(contact), project_path(@project, emails: contact.email) %>
                  <% if contact.status == ProjectMember::STATUS[:Pending] %>
                  <i class="fa fa-asterisk" data-toggle="tooltip" data-placement="top" data-original-title="Suggested Person" style="font-size:8px;"></i>
                  <% end %>
                </div>
                <div class="m-t-xs"><small><%= contact.title %></small></div>
              </td>
              <td class="editable-field pm-buyer-role-td-<%= contact.id %>">
                <%= best_in_place @contacts_pm[contact.id].first, :buyer_role, as: :select, collection: ProjectMember::BUYER_ROLE.values.map { |r| [r,r] }, inner_class: 'bip-select-input', activator: '.pm-buyer-role-td-'+contact.id %>&nbsp;&nbsp;<i class="fa fa-pencil editable-field-activator"></i>
              </td>
              <% last_touch_type = if contact.last_sent_date.present? && contact.last_reply_date.present?
                                     if contact.last_sent_date.present? && contact.last_reply_date.blank?
                                       :sent
                                     elsif contact.last_reply_date.present? && contact.last_sent_date.blank?
                                       :reply
                                     else
                                       contact.last_sent_date > contact.last_reply_date ? :sent : :reply
                                     end
                                   end %>
              <% last_touch_ts = if last_touch_type == :reply
                                   contact.last_reply_date
                                 elsif last_touch_type == :sent
                                   contact.last_sent_date
                                 end %>
              <td data-order="<%= last_touch_ts.to_i %>">
                <% if last_touch_type == :reply %>
                  <!-- Last touch was external to internal -->
                  <a data-href="<%= project_path(@project) %>#<%= contact.last_reply_message_id %>" data-id="<%= contact.last_reply_id %>" data-message-id="<%= contact.last_reply_message_id %>" class="email-data-tooltip text-info"><i class="fa fa-sign-in"></i></a>&nbsp;&nbsp;<%= last_touch_ts.in_time_zone(current_user.time_zone).strftime('%b %e') %>
                <% elsif last_touch_type == :sent %>
                  <!-- Last touch was internal to external -->
                  <a data-href="<%= project_path(@project) %>#<%= contact.last_sent_message_id %>" data-id="<%= contact.last_sent_id %>" data-message-id="<%= contact.last_sent_message_id %>" class="email-data-tooltip text-success"><i class="fa fa-sign-out fa-flip-horizontal"></i></a>&nbsp;&nbsp;<%= last_touch_ts.in_time_zone(current_user.time_zone).strftime('%b %e') %>
                <% end %>
              </td>
              <td title="<%= Time.zone.at(contact.last_meeting_date).strftime('%l:%M%p on %B %-d %Y') if contact.last_meeting_date.present? %>" data-order="<%= contact.last_meeting_date.to_i %>"><%= Time.zone.at(contact.last_meeting_date).strftime('%b %e') if contact.last_meeting_date.present? %></td>
              <td title="<%= Time.zone.at(contact.next_meeting_date).strftime('%l:%M%p on %B %-d %Y') if contact.next_meeting_date.present? %>" data-order="<%= contact.next_meeting_date.to_i %>"><%= Time.zone.at(contact.next_meeting_date).strftime('%b %e') if contact.next_meeting_date.present? %></td>
              <% @BGINFO_PREV_LEN_MAX = 35 %>
              <td class="editable-field contact-bg-info-td-<%= contact.id %>"><%= best_in_place contact, :background_info, :as => 'textarea', :place_holder => "&nbsp;", :display_with => lambda { |v| v.present? && v.respond_to?(:to_s) && v.to_s.length > @BGINFO_PREV_LEN_MAX ? v[0...@BGINFO_PREV_LEN_MAX] + "..." : v }, :activator => '.contact-bg-info-td-'+contact.id %><i class="fa fa-pencil bip_activator m-l-xs editable-field-activator"></i></td>
            </tr>
          <% end %>
          </tbody>
        </table>
      </div>
    </div>
  </div>
<script type="text/javascript" charset="utf-8">
$(function () {
  //DataTables
  $('#contacts-table').DataTable({
    responsive: true,
    "order": [[2, "desc"]],
    "lengthMenu": [[50, 100, -1], [50, 100, "All"]],
    "dom": ' <"col-sm-4 row"f><"top">rt<"col-sm-5"l><"col-sm-5"p><"bottom"i><"clear">',
    "language": {
      search: "_INPUT_",
      searchPlaceholder: "Start typing to filter list..."
    }
  });
});

  $('.email-data-tooltip').tooltip({
    title: getEmailData,
    html: true,
    container: 'body'
  });

  var cachedData = {};
  function getEmailData() {
    var element = $(this);
    var messageId = element.data('message-id');
    // only make request for email body if data not already stored here
    if (!(messageId in cachedData)) {
      var id = element.data('id');
      console.log(messageId);
      // save response in cachedData
      $.ajax({
        dataType: "json",
        url: '/activities/' + id + '/message',
        data: { message_id: messageId },
        async: false
      }).done(function (data) {
        cachedData[messageId] = data;
      }).fail(function () {
        cachedData[messageId] = { body: "error"}
      });
    }
    var data = cachedData[messageId];
    if (('from', 'to', 'sentDate') in data) {
      return '<b>' + data.from + '</b> to ' + data.to + '<br><span style="padding-top: 5px;color: grey;">' + data.sentDate + '</span><hr style="margin: 10px 0;>' + data.body;
    }
    else {
      return data.body;
    }
  }

  $('.email-data-tooltip').hover(function(){
    $('.tooltip-inner').css('background-color', 'white');
    $('.tooltip-inner').css('color', 'black');
    $('.tooltip-inner').css('opacity', '1');
    $('.tooltip-inner').css('padding', '15px 15px');
    $('.tooltip-inner').css('max-width', '512px');
    $('.tooltip-inner').css('text-align', 'left');

    $('.tooltip').css('background-color', 'white');
    $('.tooltip').css('opacity', '1');
    $('.tooltip').css('border-style','solid');
    $('.tooltip').css('border-width', '1px');
    $('.tooltip').css('border-color', '#eeeeee');
    $('.tooltip').css('boxShadow', '0px 0px 20px #aaaaaa');
    $('.tooltip-inner-content').css('margin-bottom', '7px');
    $('.tooltip-arrow').css('opacity', '0');
  });
</script>
<style>
    .link {
        stroke: #999;
        stroke-opacity: 0.6;
    }

    .node {
        stroke: #fff;
        stroke-width: 1.5px;
    }

    div.arg-tooltip {
        position: absolute;
        text-align: center;
        line-height: 1;
        padding: 12px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        border-radius: 2px;
        pointer-events: none;
    }
    div.pinned {
        color: #e8941a;
        position: absolute;
        z-index: 9999;
    }
    g.cell {
        cursor: pointer;
    }
    g.cell:hover {
        fill-opacity: 0.4;
    }
    g.cell.active:hover {
        fill-opacity: 1;
    }
    g.cell text {
        fill: black;
        -moz-user-select: none;
       -khtml-user-select: none;
       -webkit-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    g.cell.active text{
        fill: #e8941a;
    }
    .legendSize circle {
        fill: #999;
        fill-opacity: 0.6;
    }
    .legendContainer > text {
        font-size: 30px;
    }
    .legendContainer > text:nth-child(2) {
        font-size: 14px;
    }
    .legendContainer {
        padding: 0;
    }
    .legendCells circle.swatch {
        stroke: #999;
    }

    .activeNode {
        cursor: pointer;
    }
    .baseNode {
        stroke: #e8941a;
        stroke-width: 3px;
    }
    .node-name {
        stroke: none;
        fill: black;
    }
    svg {
        fill: white;
    }
    .profile-pic {
        width: 56px;
        height: 56px;
        border-radius: 56px;
        margin-right: 5px;
        border: 2px solid <%= ApplicationHelper::CONTEXTSMITH_BLUE %>;
        font-size: 22px;
        line-height: 47px;
    }
    input.selected {
        color: white;
        background: linear-gradient(to bottom, <%= ApplicationHelper::CONTEXTSMITH_BLUE %>,<%= ApplicationHelper::CONTEXTSMITH_DARKBLUE %>);
        border: 2px solid <%= ApplicationHelper::CONTEXTSMITH_BLUE %>;
    }
</style>
<script type="text/javascript">
    // Function for moving nodes to front
    d3.selection.prototype.moveToFront = function() {
      return this.each(function(){
        this.parentNode.appendChild(this);
      });
    };

    // Function for moving to back
    // d3.selection.prototype.moveToBack = function() {
    //     return this.each(function() {
    //         var firstChild = this.parentNode.firstChild;
    //         if (firstChild) {
    //             this.parentNode.insertBefore(this, firstChild);
    //         }
    //     });
    // };

    var scaleFactor = 1;
    var translation = [0,0];

    var smallCircleSize = 4.5;
    var largeCircleSize = 9;

    var legendWidth = 0;
    var xMargin = 20;

    var yMargin = 40;
    //var legendSizePadding = 10;
    var legendDomainPadding = 5;  // legend element
    var legendElementCircleSize = 8;  // radius
    var legendGroupMargin = 15;  // space between filter groups

    var height = 500;
    var width = 0;

    var linkStrokeWidthMin = 1;  // node edge will be no smaller than this width
    var linkStrokeWidthMax = 7;  // node edge will be no larger than this width

    // Configure force layout
    var force = d3.layout.force();

    var lookupURL = '/projects/<%=project_id%>/lookup.json';
    var networkURL = '/projects/<%=project_id%>/network_map.json';  // TODO: may use ".../network_map.json?start_date=12345"

    // Display refresh animation while loading data
    d3.select("#force-graph").append("div").attr("style", "padding: "+(height/2 - 16)+"px 42%; color: <%=ApplicationHelper::CONTEXTSMITH_BLUE%>").append("i").attr("class", "fa fa-refresh fa-3x fa-spin")
    d3.select("#force-graph").selectAll("div").append("p").html("Loading data...").attr("style", "display: inline; margin-left: 8px");

    // Initial graph (all dates)
    d3.json(lookupURL, function (error, lookup) {
        if (error) throw error;
        d3.json(networkURL, function (error, links) {
            if (error) throw error;
            d3.select("#force-graph").selectAll("*").remove(); // clear animation
            var metadata = links.map(function(l){ return l.count;}).reduce(function(m, a) { return { count_min: (a < m.count_min || !m.count_min ? a : m.count_min), count_max: (a > m.count_max || !m.count_max ? a : m.count_max)}; }, { count_min: undefined, count_max: undefined })
            // *** For debug ***
            // lookup.forEach(function(l){ console.log(" email: " + l.email + ", buyer_role: " + l.buyer_role + ", team: " + l.team + ", profile_img_url: " + l.profile_img_url + ", is_external: " + l.is_external + ", is_suggested: " + l.is_suggested) + "..." + l; });
            // links.forEach(function(l){ console.log(" source: " + l.source + ", target: " + l.target + ", count: " + l.count) + "..." + l; });
            ready(lookup, links, metadata);
        })
    });

    function ready(lookup, links, metadata) {
        // The 'lookup' variable refers to data from the lookup.txt file
        // The 'links' variable refers to data from the map.txt file
        
        var allShowing = true;
        var nameSelected = false;
        var nodeHighlighted = false;
        var timeout;

        var mousePos = [0,0];
        var newMousePos = [0,0];

        /*** Configure zoom behaviour ***/
        // var zoomer = d3.behavior.zoom()
        //                 .scaleExtent([0.1,10])
        //         //allow 10 times zoom in or out
        //                 .on("zoom",zoom);
        //         //define the event handler function

        // function zoom(d) {

        //     if (d3.event.sourceEvent && !nodeHighlighted){
        //         d3.event.sourceEvent.stopPropagation();
        //     }
        //     scaleFactor = d3.event.scale;
        //     translation = d3.event.translate;
        //     tick(); //update positions
        // }

        /*** Configure drag behaviour ***/
        var isDrag = false;
        var drag = d3.behavior.drag()
            .origin(function(d) { return d; }) //center of circle
            .on("dragstart", dragstarted)
            .on("drag", dragged)
            .on("dragend", dragended);

        var getMousePos;

        function dragstarted(d){
            if(d3.select(this).classed("activeNode")){
                getMousePos = d3.mouse(vis.node());
                mousePos[0] = getMousePos[0];
                mousePos[1] = getMousePos[1];
                d3.select(this).moveToFront();
                d3.event.sourceEvent.stopPropagation();
                d3.select(this).classed("dragging", true);
                force.stop(); //stop ticks while dragging
                isDrag = true;
            }
        }
        function dragged(d){
            if(d3.select(this).classed("activeNode")){
                if (d.fixed) return; //root is fixed

                //get mouse coordinates relative to the visualization
                //coordinate system:
                var mouse = d3.mouse(vis.node());
                d.x = (mouse[0] - translation[0])/scaleFactor;
                d.y = (mouse[1] - translation[1])/scaleFactor;
                tick();//re-position this node and any links
            }
        }
        function dragended(d){
            if(d3.select(this).classed("activeNode")){
                getMousePos = d3.mouse(vis.node());
                newMousePos[0] = getMousePos[0];
                newMousePos[1] = getMousePos[1];
                var shortDrag = Math.abs(newMousePos[0] - mousePos[0]) < 5 && Math.abs(newMousePos[1] - mousePos[1]) < 5;
                if(shortDrag){ // Short drag means click
                    connectedNodes(d, allShowing || nameSelected, this); // else highlight connected nodes
                }

                d3.select(this).classed("dragging", false);
                // if(!shortDrag) {force.resume();} // Resume force layout only if not a short drag
                isDrag = false;
            }
        }

        //Initialize SVG
        var graph = d3.select("#force-graph").append("svg")
            .append("g")
            .attr("class", "graph");
            // .on("mousedown", function(){
            //     mousePos = d3.mouse(this);
            //     if(mousePos[0] < legendWidth && mousePos[1] < height) d3.event.stopImmediatePropagation(); //Only clicks no drag or pan on menu area
            // })
            // .call(zoomer);
        graph.append("rect")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("fill", "white")
            .attr("class", "background")
            .attr("fill-opacity", 0.9);

        // Rectangle to catch mouse events for zoom
        var rect = graph.append("rect")
            .attr("width", "100%")
            .attr("height", "100%")
            .style("margin", "0 auto")
            .style("fill", "none")
            .style("pointer-events", "all")
            // .style("cursor", "move")
            .on("click", function(){  // clicking an empty space on the graph
                if (d3.event.defaultPrevented) return;
                showAllNodes(true);
            });

        // Create a group that will hold all content to be zoomed
        var vis = graph.append("svg:g")
            .attr("class", "plotting-area");

        // Pinned tooltip
        var pinnedTooltip = d3.select("#force-graph").append("div")
            .attr("class", "arg-tooltip pinned")
            .style("right", "40px")
            .style("top", "70px")
            .style("opacity", "0");

        // Tooltip in top right corner
        var tooltip = d3.select("#force-graph").append("div")
            .attr("class", "arg-tooltip")
            .style("right", "40px")
            .style("top", "70px")
            .style("opacity", "0");

        // Container to hold legend elements
        var legendContainer = graph.append("g")
                        .attr("class", "legendContainer");

        // Title of visualization
        var vizTitle = legendContainer.append("text")
            .attr("x", xMargin)
            .attr("y", yMargin)
            .style("fill", "black")
            .text("Account Relationship Graph");

        // // Create a legend for big/small nodes
        // legendContainer.append("g")
        //     .attr("class", "legendSize")
        //     .attr("transform", "translate("+ (xMargin+10) + ", 70)");

        // var legendSize = d3.legend.size()
        //     .scale(linearSize)
        //     .shape('circle')
        //     .shapePadding(legendSizePadding)
        //     .labels(["Small Node","Big Node"])
        //     .cells(2) // Number of objects (circles)
        //     .ascending(true);

        // var sizeLegend = legendContainer.select(".legendSize")
        //     .call(legendSize);

        // Create hash for all node info
        var nodesByEmail = {};
        // Add node info for each opportunity member
        lookup.forEach(function(person) {
            var suggested = person.is_suggested ? " *" : ""
            nodesByEmail[person.email] = {
                email: person.email,
                name: (person.name+suggested) || "(None)",
                title: person.title || "(No title)",
                profile_img_url: person.profile_img_url,
                buyer_role: person.buyer_role || (!person.is_external ? undefined : "(No buyer role)"),
                team: person.team || (person.is_external == undefined || person.is_external ? undefined : "(No team)"),
                domain: person.domain,
                meetings: person.meetings,
                key_activities: person.key_activities,
                is_external: person.is_external,
                is_suggested: person.is_suggested,
                inbound: 0,
                outbound: 0
            };
        });
        // Add node info for each source and target from e-mail data
        links.forEach(function(link) {
            link.source = nodeByEmail(link.source, +link.count, 0);
            link.target = nodeByEmail(link.target, 0, +link.count);
        });
        function nodeByEmail(email, outbound, inbound) {
            // Dynamically create nodes with dummy info when e-mail address in e-mail data not added as project member
            if (!nodesByEmail[email]) {
                nodesByEmail[email] = {
                    email: email,
                    name: email.split("@")[0],
                    title: undefined,
                    profile_img_url: undefined,
                    buyer_role: undefined,  //cannot determine w/o knowing if external/internal
                    team: undefined,        //cannot determine w/o knowing if external/internal
                    domain: email.split("@")[1],
                    meetings: 0,
                    key_activities: 0,
                    is_external: undefined,
                    is_suggested: undefined,
                    inbound: 0,
                    outbound: 0
                }
            }
            nodesByEmail[email].inbound += inbound;
            nodesByEmail[email].outbound += outbound;
            return nodesByEmail[email];
        }

        // Extract the array of nodes from the hash by email.
        var nodes = d3.values(nodesByEmail);
        // Extract all unique domains from the nodes to use for filter
        var domains = nodes.map(function (obj) { return obj.domain; })
            .filter(function (domain, i, arr) { return arr.indexOf(domain) === i; });
        var buyerRoles = nodes.filter(function (obj, i, arr) { return obj.is_external; })
            .map(function (obj) { return obj.buyer_role; })
            .filter(function (buyer_role, i, arr) { return arr.indexOf(buyer_role) === i && buyer_role != undefined; });
        var teams = nodes.filter(function (obj, i, arr) { return !obj.is_external; })
            .map(function (obj) { return obj.team; })
            .filter(function (team, i, arr) { return arr.indexOf(team) === i && team != undefined; });
        var additionalFilters = ["Suggested People *"];
        var legendValues = domains.concat(buyerRoles).concat(teams).concat(additionalFilters);

        // Linear size scale
        // var linearSize = d3.scale.linear().domain([0,1]).range([smallCircleSize, largeCircleSize]);

        // Create a legend for legendValues
        legendContainer.append("g")
            .attr("class", "legendOrdinal")
            .attr("transform", "translate("+ (xMargin+10) + ", 70)");

        // Initialize Ordinal Colour Scale
        var availColors = ["#003366", "#009933", "#ff9933", "#ff0000", "#996633", "#ff66ff", "#0000cc", "#ffcccc", "#00ccff"];
        var colorScale = [];
        domains.forEach(function (c,i) { colorScale.push(availColors[i % availColors.length]); });
        var color = d3.scale.ordinal()
        // TODO: redo the scale to make dynamic
            .domain(legendValues)
            .range(colorScale.concat(fillArray("#EFEFEF", legendValues.length - domains.length)));

        // Helper to repeat colors
        function fillArray(value, len) {
          var arr = [];
          for (var i = 0; i < len; i++) {
            arr.push(value);
          }
          return arr;
        }

        var legendOrdinal = d3.legend.color()
            .shape("circle")
            .shapePadding(legendDomainPadding)
            .scale(color)

        var domainLegend = legendContainer.select(".legendOrdinal")
            .call(legendOrdinal);

        d3.selectAll("circle.swatch")
            .each(function(d,i) {
                d3.select(this).attr("r", legendElementCircleSize);
            });

        // Temporary hack: put spaces in between domains/buyer_roles/teams in the legend
        var clientWidth = d3.select('#force-graph').node().clientWidth;
        d3.selectAll("g.cell")
            .each(function(d,i) {
                var adjust = 0;
                if (i >= domains.length) adjust += legendGroupMargin;
                if (i >= domains.length + buyerRoles.length) adjust += legendGroupMargin;
                if (i >= domains.length + buyerRoles.length + teams.length) adjust += legendGroupMargin;

                // Temporary hack: wrap filter selection to the other side of the graph
                var x = 0;
                var y = (i * (legendElementCircleSize * 2 + 4) + adjust);
                if (y >= 430) {
                    y = y - 430;
                    x = clientWidth - 150;
                }

                d3.select(this).attr("transform", "translate(" + x + "," + y + ")");
            });


        // Filtering
        d3.selectAll("g.cell")
            .on("click", function(val, i){
                if (d3.event.defaultPrevented) return;
                var self = this;
                var activeLegends = d3.selectAll("g.cell");

                activeLegends.filter(function (x) {return self != this;})
                    .classed("active", false); // Set all other filters to false

                pinnedTooltip.style("opacity", 0);
            //    zoomer.translate([20, 0]);

                if (i < domains.length)
                    filterNode("domain", val, this);
                else if (i >= domains.length && i < domains.length + buyerRoles.length)
                    filterNode("buyer_role", val, this);
                else if (i >= domains.length + buyerRoles.length && i < domains.length + buyerRoles.length + teams.length)
                    filterNode("team", val, this);
                else
                    filterNode("suggested", val, this);
            });

        // Create the link lines.
        var link = vis.selectAll(".link")
              .data(links)
            .enter().append("line")
              .attr("stroke-width", function(d) { return (d.count - metadata.count_min)/(metadata.count_max - metadata.count_min) * linkStrokeWidthMax || linkStrokeWidthMin; })
              .attr("class", "link");

        // Create the node circles.
        var nodeGroup = vis.selectAll(".node-group")
              .data(nodes)
            .enter().append("g")
              .attr("class", "node-group")
              .style("fill", "black");

        // node - group of all nodes
        var node = nodeGroup.append("circle")
              .attr("class", "node")
              .attr("r", function(d) {
                  return smallCircleSize + (d.inbound + d.outbound)/10;
              })
              .style("fill", function(d) {return color(nodesByEmail[d.email].domain);})
              .classed("activeNode", true)
              .on("mouseover", function(d){
                  var profile_img_html = (d.is_external != undefined && d.profile_img_url != undefined) ? "<img src='" + d.profile_img_url + "' class='profile-pic' title='profile pic'>" : "";

                  if(d3.select(this).classed("activeNode") && !d3.select(this).classed("baseNode")){
                    force.stop();
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", 0.9);
                    tooltip.html(profile_img_html + "<strong style=\"font-size:16px;\">" + d.name + "</strong><br>Title: " + d.title + (d.is_external ? "<br>Buyer Role: " + d.buyer_role : "") + (d.is_external != undefined && !d.is_external ? "<br>Team: " + d.team : "") /*+ "<br>Outbound: " + d.outbound + "<br>Inbound: " + d.inbound*/ + "<br>Meetings: " + d.meetings + "<br>Key Activities: " + d.key_activities /*+ "<br>** external? " + d.is_external + "**"*/)
                        .style("top", (nodeHighlighted?"225px":"70px"));
                  }
              })
              .on("mouseout", function(d){
                  // if (!isDrag && !nodeHighlighted) { force.resume(); } // resumes when node is moused-out
                  tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
              })
              .call(drag);

        var nodeName = nodeGroup.append("text")
            .attr("class", "node-name")
            .attr("x", function(d) { return d.name.length*-3; })
            .attr("y", function(d) { return smallCircleSize + (d.inbound + d.outbound)/10 + 10; })
            .text(function(d) { return d.name; });

        // Start the force layout.
        force
            .nodes(nodes)
            .links(links)
            .charge(-200)
            // .linkDistance(function(d) { return 20 + nodes.length*10 - (d.source.inbound + d.source.outbound)/20; })
            .linkDistance(100 + nodes.length*2)
            .linkStrength(0.08)
            .on("tick", function(){tick();})
            .start();

        // TODO: Uncomment if performance is bad.
        // graph
        //     .on("mouseleave", function(){
        //         force.stop();
        //     })
        //     .on("mouseenter", function(){
        //         force.resume();
        //     });

        //Create an array logging what is connected to what
        var linkedByIndex = {};
        for (i = 0; i < nodes.length; i++) {
            linkedByIndex[i + "," + i] = 1;
        };
        links.forEach(function (d) {
            linkedByIndex[d.source.index + "," + d.target.index] = 1;
        });

        //This function looks up whether a pair are neighbours
        function neighboring(a, b) {
            return linkedByIndex[a.index + "," + b.index];
        }

        // Change opacity to "highlight" connected nodes when a node is clicked
        function connectedNodes(clickedOn, firstClick, nodeClicked) {
            nodeHighlighted = true;
            d3.selectAll("g.cell").classed("active", false); // Clear filters
            if (d3.select(nodeClicked).classed("baseNode")){ // Base node was clicked, show all
                showAllNodes(false);
                return;
            }
            force.stop(); // Stop moving
            tooltip.style("opacity", 0); // Clear unpinned tooltip (because it is the same as the pinned)

            var profile_img_html = (clickedOn.is_external != undefined && clickedOn.profile_img_url != undefined) ? "<img src='" + clickedOn.profile_img_url + "' class='profile-pic' title='profile pic'>" : "";
            pinnedTooltip.transition()
                .duration(200)
                .style("opacity", 0.9);
            pinnedTooltip.html(profile_img_html + "<strong style=\"font-size:16px;\">" + clickedOn.name + "</strong><br>Title: " + clickedOn.title + (clickedOn.is_external ? "<br>Buyer Role: " + clickedOn.buyer_role : "") + (clickedOn.is_external != undefined && !clickedOn.is_external ? "<br>Team: " + clickedOn.team : "") /*+ "<br>Outbound: " + clickedOn.outbound + "<br>Inbound: " + clickedOn.inbound*/ + "<br>Meetings: " + clickedOn.meetings + "<br>Key Activities: " + clickedOn.key_activities /*+ "<br>** external? " + clickedOn.is_external + "**"*/) // Pin tooltip with name of clicked on node
            pinnedTooltip.moveToFront();
            node.each(function(d){ // Allow for clicking back on previous baseNodes
                d3.select(this).classed("baseNode", false);
            });
            d3.select(nodeClicked).classed("baseNode", true);
            node.classed("activeNode", function(o){
                return neighboring(clickedOn, o) | neighboring(o, clickedOn) ? true : false;
            })
            node.style("stroke-opacity", function (o) {
                return (neighboring(clickedOn, o) | neighboring(o, clickedOn)) ? 1 : 0.1;
            });
            node.style("fill-opacity", function (o) {
                return (neighboring(clickedOn, o) | neighboring(o, clickedOn)) ? 1 : 0.1;
            });
            link.style("stroke-opacity", function (o) {
                return clickedOn.index==o.source.index | clickedOn.index==o.target.index ? 0.6 : 0.1;
            });
            nodeName.style("opacity", function (o) {
                return (neighboring(clickedOn, o) | neighboring(o, clickedOn)) ? 1 : 0.1;
            });
            d3.select("activeNode").moveToFront(); // Brings activeNode nodes to front
            allShowing = false;
            nameSelected = false;
        }

        // Change opacity to "highlight" all relevant nodes when applying filter
        function filterNode(searchType, searchVal, gObject) {
            nodeHighlighted = false;
            var allNodes = d3.selectAll(".node");
            var notSelectedNodes = allNodes.filter(function (d, i){
                if (searchType == "domain")
                    return nodesByEmail[d.email].domain != searchVal;
                else if (searchType == "buyer_role")
                    return nodesByEmail[d.email].buyer_role != searchVal;
                else if (searchType == "team")
                    return nodesByEmail[d.email].team != searchVal;
                else // searchType == "suggested"
                    return !nodesByEmail[d.email].is_suggested;
            });
            var selectedNodes = allNodes.filter(function (d, i){
                if (searchType == "domain")
                    return nodesByEmail[d.email].domain == searchVal;
                else if (searchType == "buyer_role")
                    return nodesByEmail[d.email].buyer_role == searchVal;
                else if (searchType == "team")
                    return nodesByEmail[d.email].team == searchVal;
                else // searchType == "suggested"
                    return nodesByEmail[d.email].is_suggested;
            });

            var link = d3.selectAll(".link");
            if (!d3.select(gObject).classed("active")){
                selectedNodes
                    .style("stroke-opacity", 1)
                    .style("fill-opacity", 1)
                    .classed("activeNode", true);
                notSelectedNodes
                    .style("stroke-opacity", 0.1)
                    .style("fill-opacity", 0.1)
                    .classed("activeNode", false);
                // selected names
                d3.selectAll(".node.activeNode").select(function(){ return (this.nextSibling || this.previousSibling); })
                    .style("opacity", 1);
                // not selected names
                d3.selectAll(".node:not(.activeNode)").select(function(){ return (this.nextSibling || this.previousSibling); })
                    .style("opacity", 0.1);

                link.style("stroke-opacity", 0.1);

                d3.select(gObject).classed("active", true);
                nameSelected = true;
                allShowing = false;
            }
            else { // deselect a selected filter
                d3.select(gObject).classed("active", false);
                showAllNodes();
            }
        }

        // Unselected + show all nodes; resume_force - resets fixed node positions 
        function showAllNodes(resume_force=false){
            if(d3.event.stopPropagation){d3.event.stopPropagation();}
            if (resume_force) { force.resume(); }

            //Put them back to opacity=1
            node
                .style("stroke-opacity", 1)
                .style("fill-opacity", 1)
                .classed("activeNode", true)
                .classed("clickedNode", false)
                .classed("baseNode", false);
            link.style("stroke-opacity", 0.6);
            nodeName.style("opacity", 1);
            d3.selectAll("g.cell").classed("active", false); // Clear filters
            allShowing = true;
            nameSelected = false;
            nodeHighlighted = false;
            pinnedTooltip.style("opacity", 0);
        }

        // Update positions of nodes and links
        function tick() {
            link.attr("x1", function(d) { return translation[0] + scaleFactor*d.source.x; })
                .attr("y1", function(d) { return translation[1] + scaleFactor*d.source.y; })
                .attr("x2", function(d) { return translation[0] + scaleFactor*d.target.x; })
                .attr("y2", function(d) { return translation[1] + scaleFactor*d.target.y; });

            // node.attr("cx", function(d) { return translation[0] + scaleFactor*d.x; })
            //     .attr("cy", function(d) { return translation[1] + scaleFactor*d.y; });
            nodeGroup.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
        }

        resize();
        d3.select(window).on("resize", resize);

        function resize() {
            var graphContainer = d3.select('#force-graph').node();
            width = graphContainer.clientWidth;
            // height = graphContainer.clientHeight;
            d3.select("svg").attr("width", width).attr("height", height);
            force.size([width, height]).resume();

            // Temporary hack: Dynamically wrap a long list of filter items (once) over to the other side (right edge) of the window
            d3.selectAll("g.cell")
                .each(function(d,i) {
                    var t = d3.select(this).attr("transform");
                    var x = t.split(",")[0].substring(10);
                    var y = t.split(",")[1].substring(0,t.split(",")[1].indexOf(")"));

                    if (x > 0) {
                        x = width - 150;
                        d3.select(this).attr("transform", "translate(" + x + "," + y + ")");
                    }
                });

            legendContainer.moveToFront();
            tick();
        }
    } // function ready(...)

    $("#LAST_14d, #LAST_30d, #LAST_60d, #LAST_90d, #LAST_180d, #ALL_DATES").click(function(){
        $("#LAST_14d, #LAST_30d, #LAST_60d, #LAST_90d, #LAST_180d, #ALL_DATES").attr("class", "");
        $("#"+this.id).attr("class", "selected");
        $("#"+this.id).blur();
        d3.select("#force-graph").selectAll("*").remove(); // clear graph

        // Display refresh animation while loading data
        d3.select("#force-graph").append("div").attr("style", "padding: "+(height/2 - 16)+"px 42%; color: <%=ApplicationHelper::CONTEXTSMITH_BLUE%>").append("i").attr("class", "fa fa-refresh fa-3x fa-spin")
        d3.select("#force-graph").selectAll("div").append("p").html("Loading data...").attr("style", "display: inline; margin-left: 8px");

        if (this.id == "ALL_DATES")
            networkURL = "/projects/<%=project_id%>/network_map.json";
        else
            networkURL = "/projects/<%=project_id%>/"+this.id+"/network_map.json";

        var force = d3.layout.force();
        d3.json(lookupURL, function (error, lookup) {
            if (error) throw error;
            d3.json(networkURL, function (error, links) {
                if (error) throw error;
                d3.select("#force-graph").selectAll("*").remove(); // clear animation
                var metadata = links.map(function(l){ return l.count;}).reduce(function(m, a) { return { count_min: (a < m.count_min || !m.count_min ? a : m.count_min), count_max: (a > m.count_max || !m.count_max ? a : m.count_max)}; }, { count_min: undefined, count_max: undefined })
                // *** For debug ***
                // lookup.forEach(function(l){ console.log(" email: " + l.email + ", buyer_role: " + l.buyer_role + ", team: " + l.team + ", profile_img_url: " + l.profile_img_url + ", is_external: " + l.is_external + ", is_suggested: " + l.is_suggested) + "..." + l; });
                // links.forEach(function(l){ console.log(" source: " + l.source + ", target: " + l.target + ", count: " + l.count) + "..." + l; });
                ready(lookup, links, metadata);
            })
        });
    });

</script>
<% else %>
  <div class="p-m m-l white-bg header-box">
    <h4 class="text-center">Nothing to graph because there are no activities!</h4>
  </div>
<% end %>

<script type="text/javascript">
    $("#arg-link").parent().addClass("active");
</script>
